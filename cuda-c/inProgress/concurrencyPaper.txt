Operational semantics for C concurrency.
Benefits:
	executable
	extends full semantics of C
	catches races
	tests theories about model
	incidentally shows modularity of k
	comparison with TSO
	plug in model?
	is it possible to execute the HOL/Isabelle definitions?
	run programs to test model
	get adve involved
	
buffers
synchronization points
queues?  representation of order? (tree?)
separate representation of atomics?
possible to compute sets of all values able to be read?
pendulate on above

need to implement:
	thread_local ?
	mutexes in K
	_atomics & macros
	load & store parameterized functions
	
	

	
(look at tso in K and thesis)
	

	
	
----------------------------------

stuff to add in imp:
stage1 (seq consistent model):
not atomics
no low level synchronization
lock/unlock
load and store


x = f(y)

y < f
f < =
x < =
y < =

x = f(y) + f(z)
+ > y 
+ > z
+ > f1
+ > f2

x , y

x < y
x < ,
y < ,



computeSequencing(E) = {(a, b) (c, d) (a, d)}

context (HOLE => before(+, HOLE)) + _:K



(14)
Sequenced before

(18)
release sequence
synchronize with

carries a dependency
(19)
dependency-ordered before
inter-thread happens before
happens before
(20)
visible side effect

single memory vs distributed memory vs sets of possibilities

static ids and dynamic ids
call and return
statements

instrument code (keys to idents, keys to statements)
rule <k> wrap(X:#Id, N) => X ~> update(N) ...</k>

rule <k> Loc:#Nat ~> update(N:#Nat)
	<dynamicOrder> DO:Bag => replace N with Loc in DO </dynamicOrder>

rule <k> wrap(S:Stmt, N) => S ...</k>
	// <Local/Control>
		<dynamicOrder> DynamicOrder:Bag => StaticOrder </dynamicOrder>
		<currentStatement> Curr => Next </currentStatement>
	// </Local/Control>
	// <thread>
	<sequencedBefore>...
		. => addOrder(StaticOrder, Curr, Next)
	...</sequencedBefore>
	<nextStatement> Next => Next + 1 </nextStatement>
	// </thread>
	<staticOrders>... N |-> StaticOrder:Bag ...</staticOrders> // global
	
// also create dependency relation, statically and dynamically

<k> thread_create => foobar ...</k>
<interThreadHappensBefore>... . => (E, E + 1) ...</interThreadHappensBefore>
<dynamicOrder> DO:Bag => instatiateCall(DO, ) </dynamicOrder> 
<freshEvent> E => E + 2 </freshEvent>


_Atomic x = 5;
x = 7;



int f(void){
	threadcreate();
}



event(uniqueId)

<events>
	<event multiplicity="*">
		<uniqueId/>
		<myThreadId/>
		<kind/>
		<location multiplicity="?"/>
		<value multiplicity="?"/>
	</event>
</events>


f() + g();  



